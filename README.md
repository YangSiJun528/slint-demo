# Slint로 이거저거 해보기

https://docs.slint.dev/latest/docs/slint//tutorial/quickstart/

## 결론

유기. UI가 직관적인건 좋은데, 커스터마이징 기능이 떨어짐.

ScrollView에 Scrollbar 스타일을 바꾸고 싶은데 지원을 안함. 바꿀 수 있는 방법이 없음. 그렇다고 ScrollView를 만드는건 너무 과함.

그리고 ScrollView 스타일이 너무 구려 스크롤에 호버 들어가서 커지는건 또 뭐임;; 뭐 임베디드같은 다양한 환경도 지원해야해서 사용성 고려한거면 몰라도, 제어할 수는 있게 해줘야지. 

그냥 디자인 요소에 크게 신경을 쓰지 않고 개발하는거면 성능이나 크로스 컴파일 면에서 다른 라이브러리 대비 안정적인거 같긴 한데, 웹 개발하는거처럼 높은 자유도를 생각하면 답답함.

막 회사에서 준 디자인 그대로 작업해야 하는 경우면 slint를 쓰면 좀 작업하기 어려울 듯.

나는 만들려고 하는 프로젝트가 GUI가 좀 보기 좋았으면 좋겠어서, 그냥 안쓰기로 함. iced 한번 봐보고, 이것도 커스터마이징 별로면 그냥 tauri로 옮겨서 웹으로 편하게 할 듯?

## 튜토리얼 이후 시점 후기

- 막 엄청 복잡하진 않은데, 그렇다고 엄청 UX 좋은건 또 아닌듯?
- 도구 연동이나 그런 부분에서 익숙하지 않은것도 있고, 부족한 부분도 많을거 같음.
- 못 쓸 정도는 아님. 간단한건 괜찮아 보이는데?

## 짦게 햇갈렸던 부분 위주로 정리

공식문서가 잘되어있고, 양도 얼마 안되서 금방 다 읽을 수 있음.  
아니면 문서 복붙해서 AI한테 내용 기반으로 물어봐달라 할 수도 있고.

### TODO
- 예시들 보고 할거
  - 국제화
  - 적당한 아키텍처 까지
  - 일단 구현해보기?
  - 테스트코드 짜는것도

### 핵심 개념

- `.slint`: declarative(선언형) UI language 임. 
  - 왜 slint 씀?: 
    - 문제
      - SwiftUI, React는 기존 언어를 섞어서 선언적으로 쓰려고 함. -> 잘 안맞음.
      - UI 선언이랑 비즈니스 로직이 섞임.
    - 해결: 순수한 선언 언어인 slint를 쓰자
      - 이러면 비개발자도 보기 쉽고, 역할이 명확하게 나뉘고 하는 장점이 있음.
- 반응형(Reactivity)
  - 반응형임. React 처럼 diff가 아님. SolidJS랑 비슷한 방식임.
  - `.slint`에서 property나 callback/pure function으로 반응형 처리 필요한 데이터/동작을 명세하면, 컴파일러?가 인식하고 반응형으로 동작하도록 결과물을 만들어냄.
- 반응형 시스템에서의 순수성(Purity)
  - 반응형 시스템이 제대로 동작하려면, property를 평가할 때 관찰 가능한 상태를 변경하면 안됨.
  - 이유
    - 지연 평가(Lazy evaluation): 언제 평가될지 예측 불가
    - 평가 순서 변경: 최적화에 따라 실행 순서 바뀔 수 있음
    - 예측 불가능한 동작: property 바인딩 평가 중 상태 변경 시 무한 루프나 예상 밖 결과
  - 다음 3가지는 반드시 순수해야 함:
    - Property 바인딩 표현식 
    - Pure function/callback 본문
  - 순수하다는 의미(Pure context 제약사항)
    - Property 변경 불가
    - Non-pure callback/function 호출 불가
- MVVM
  - 공식적으로 이렇게 말한건 아닌데, 동작을 보면 MVVM 방식을 유도하는걸로 보임.
  - 설명하기엔 길어서 AI로 정리함. [MVVM 구성요소와 Slint의 대응](https://gist.github.com/YangSiJun528/d3be6bc65c21614cd7feae13bd8744a6)
    - 근데 ViewModel을 제공하는게 아니라 MVC 패턴 or 패턴 없이 모델/뷰 로만 등으로 다양하게 사용 가능함.
    - 그래도 AI가 짜준거랑 공식 예시 보니까 MVVM 방식이 더 깔끔해보이긴 함.

### 문법

- 식별자: Function/Callback/Attribute/Property 등등에 붙이는 이름
  - 예약된 이름(재정의 불가): `root`, `self`, `parent`
  - 속성 값으로 쓰려면 expression 인 식별자만 가능 (뭐 당연하긴 함)
- `=:`: 이걸로 요소에 이름을 부여해 참조 가능
  - 예: `hello := MyButton { text: "hello"; }`

---

- 요소(Element)/컴포넌트(Component)
  - Element: Slint의 기본 빌딩 블록 (예: Rectangle, Text, Window)
  - Component: Element와 Property로 구성된 더 큰 단위
- 속성(Properties)
  - expression/statement로 값을 설정 가능
  - 반응형으로 값 변경 시 종속된 표현식 재평가 -> UI 수정
  - `[접근 제어자] property<타입> 이름 [: 기본값];` - `[]`로 감싼건 옵션
  - 접근 제어:
    - `private` (기본): 컴포넌트 내부에서만 접근(읽기/수정).
    - `in`: 외부에서 수정 가능. 컴포넌트에선 기본값 설정만 가능, 수정 불가.
    - `out`: 컴포넌트에서만 수정, 외부는 읽기 전용.
    - `in-out`: 모두 읽기/수정 가능.
    - private이 아니면 바인딩을 통해 외부에서 접근 가능.
  - 바인딩: 
    - 두 Property를 연결하는 경우 
    - 단방향(기본): `이름 : 다른프로퍼티값`. `다른프로퍼티값`이 바뀌면 `이름`이 변경. `이름`이 변경되면 `다른프로퍼티값`은 그대로.
    - 양방향: `이름 <=> 다른프로퍼티값`. 둘 중 하나라도 바뀌면 서로 변경. 데이터 동기화 필요 시 사용.
- 콜백(Callback)
  - 사용 목적: 일반적으로 콜백을 사용하는 가장 큰 이유는 백엔드 코드에서 콜백을 처리할 수 있기 때문이다. 즉, 비즈니스 로직에 의해 상태가 변경되길 바랄 때 사용할 수 있다.
  - 특징: 외부 연동 인터페이스, 런타임에 동적 바인딩
  - 접근 제어: 항상 `public` 인터페이스처럼 동작
  - 정의: `callback 이름(파라미터) [-> 반환타입];`
  - slint 내부 사용(핸들러 구현): `hello(파라미터) => { /* ... */ }` - 단, 필요 시 외부에서 핸들러 구현 가능
  - 호출: `callback 이름(파라미터);`
  - 별칭(양방향 바인딩처럼 동작): `<=>`
    - 이벤트 전파/여러 컴포넌트 동기화/호출 시 자동 전달 등 사용
    - 한쪽 callback 호출 시 다른쪽도 자동 호출됨
    - `callback my_callback <=> other_callback;`
  - Change Callbacks
    - 속성 값이 변경될 때 호출되는 콜백. 단, 무한루프 가능성/가독성 문제 등이 있으므로 바인딩으로 할당이 불가능할때만 제한적으로 사용 권장.
    - 구문: `changed 속성명 => { ... }`
- 함수(Function)
  - 사용 목적: Slint 내부에서 로직 재사용/추상화 등의 목적으로 사용.
  - 특징: UI 로직 전용, 컴파일 타임 최적화 가능
  - 접근 제어: Slint 외부에서는 접근/호출 불가
  - 예: `[pure] function add(a: int, b: int) -> int { return a + b; }`
  - pure 함수: 부작용(side effect) 없이 순수 계산만 수행. (attribute/property 읽기능 가능하나 가능하면 파라미터로 받기)
    - 기본 함수는 상태 변경 가능(property 읽기/쓰기 가능. 다른 function/callback 호출 가능.)
    - 이 경우 컴파일러 최적화가 가능하고, Purity를 지키므로 property 바인딩에서 사용 가능
- expression/statement: 
  - 일반적인 정의/특징과 크게 다르지 않음.
  - expression: `속성명: 값;` 형식. 값 반환 O, 따라서 속성 값 등등으로 사용 가능
  - statement: `{ 표현식 }` 형식, `;` 없음. 값 반환 X
- 이름 해석(Name Resolution)
  - 규칙: 요소명 없이 호출 시 self → parent → root 순으로 탐색. 요소명 지정 시 해당 요소에서만 탐색. 
  - 섀도잉: 동일 이름의 함수가 다른 요소에서 정의 가능.

---

이외의 나머지는 다음과 같은데, 뭐 크게 복잡하지도 않고, 공식문서 보면 되고 햇갈릴만한 내용은 없음.
- 주석(Comments)
- 조건문(Conditional Elements)
- 반복(Repetition)
- 구조체(Structs)와 열거형(Enums)
- 상태(States): 다양한 조건에 따른 상태 변경 처리(애니메이션,UI관련) 시 편하게 코드 작성 가능. case 느낌.
- 애니메이션(Animations)
- 글로벌(Global Singletons)
- 위치 지정 및 레이아웃(Positioning and Layouts)
- 모듈(Module): Export, Import, 컴포넌트 라이브러리(`@라이브러리명/파일` 형태로 외부/내부 라이브러리 참조 가능)

### (보완 필요) 테스트

확실하진 않은데 AI 피셜

`run()`은 이벤트 루프와 렌더링을 시작하는 것이고, UI 객체 자체는 순수한 상태 컨테이너로 동작합니다.   
테스트에서는  invoke_*` 메서드로 콜백을 직접 트리거하면 됩니다.

라고 해서, 그냥 뷰 인스턴스 만들어서 상태 변경 잘 되나 확인하면 되는듯? 이러면 단위 테스트 짜기도 쉬울듯?

뭐 UI 부분에 단위 테스트가 필요하나 싶긴 한데...
